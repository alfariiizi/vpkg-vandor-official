package vpkg_sync

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"{{.ModuleName}}/internal/utils"
)

// HttpSyncProvider provides sync functionality for HTTP routes
type HttpSyncProvider struct{}

// NewHttpSyncProvider creates a new HTTP sync provider
func NewHttpSyncProvider() *HttpSyncProvider {
	return &HttpSyncProvider{}
}

// SyncRoutes regenerates the HTTP routes registration
func (h *HttpSyncProvider) SyncRoutes() error {
	routeDir := "internal/delivery/http/route"
	var invokes []string
	importAliasMap := map[string]string{} // group => alias

	moduleName := utils.GetModuleName()

	entries, err := os.ReadDir(routeDir)
	if err != nil {
		// If route directory doesn't exist, create basic structure
		if os.IsNotExist(err) {
			return h.createBasicRouteStructure()
		}
		return err
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}

		group := entry.Name()
		groupDir := filepath.Join(routeDir, group)
		importAlias := group + "_handler"
		importAliasMap[group] = importAlias

		files, err := os.ReadDir(groupDir)
		if err != nil {
			continue
		}

		for _, file := range files {
			if strings.HasSuffix(file.Name(), ".go") && file.Name() != "service.go" {
				fset := token.NewFileSet()
				astFile, err := parser.ParseFile(fset, filepath.Join(groupDir, file.Name()), nil, parser.AllErrors)
				if err != nil {
					continue
				}

				for _, decl := range astFile.Decls {
					fn, ok := decl.(*ast.FuncDecl)
					if ok && fn.Recv == nil && fn.Name.IsExported() && strings.HasPrefix(fn.Name.Name, "Register") && strings.HasSuffix(fn.Name.Name, "Route") {
						invokes = append(invokes, fmt.Sprintf("%s.%s", importAlias, fn.Name.Name))
					}
				}
			}
		}
	}

	// Generate routes.go
	if err := h.generateRoutesFile(routeDir, importAliasMap, invokes, moduleName); err != nil {
		return err
	}

	// Generate main HTTP server if it doesn't exist
	if err := h.ensureServerExists(); err != nil {
		return err
	}

	fmt.Printf("âœ… HTTP routes synced successfully!\n")
	return nil
}

func (h *HttpSyncProvider) generateRoutesFile(routeDir string, importAliasMap map[string]string, invokes []string, moduleName string) error {
	var buf bytes.Buffer
	buf.WriteString("// Package route provides HTTP routes for the application.\n")
	buf.WriteString("// Code generated by HTTP Huma Generator. DO NOT EDIT.\n")
	buf.WriteString("// Template: https://github.com/alfariiizi/vandor-cli.\n")
	buf.WriteString("package route\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"github.com/danielgtaylor/huma/v2\"\n")
	for _, group := range sortedKeys(importAliasMap) {
		buf.WriteString(fmt.Sprintf("\t%s \"%s/internal/delivery/http/route/%s\"\n",
			importAliasMap[group], moduleName, group))
	}
	buf.WriteString("\t\"go.uber.org/fx\"\n")
	buf.WriteString("\t\"{{.ModuleName}}/internal/core/usecase\"\n")
	buf.WriteString(")\n\n")

	buf.WriteString("// RegisterAllRoutes registers all HTTP routes\n")
	buf.WriteString("func RegisterAllRoutes(api huma.API, usecases *usecase.Usecases) {\n")
	for _, invoke := range invokes {
		// Extract function name and convert to registration call
		parts := strings.Split(invoke, ".")
		if len(parts) == 2 {
			buf.WriteString(fmt.Sprintf("\t%s(api, usecases)\n", invoke))
		}
	}
	buf.WriteString("}\n\n")

	buf.WriteString("var Module = fx.Module(\n")
	buf.WriteString("\t\"route\",\n")
	buf.WriteString("\tfx.Invoke(\n")
	buf.WriteString("\t\tRegisterAllRoutes,\n")
	buf.WriteString("\t),\n")
	buf.WriteString(")\n")

	// Write to file
	return os.WriteFile(filepath.Join(routeDir, "routes.go"), buf.Bytes(), 0644)
}

func (h *HttpSyncProvider) createBasicRouteStructure() error {
	routeDir := "internal/delivery/http/route"
	if err := os.MkdirAll(routeDir, 0755); err != nil {
		return err
	}

	// Create basic routes.go
	basicRoutes := `// Package route provides HTTP routes for the application.
// Code generated by HTTP Huma Generator. DO NOT EDIT.
// Template: https://github.com/alfariiizi/vandor-cli.
package route

import (
	"github.com/danielgtaylor/huma/v2"
	"go.uber.org/fx"
	"{{.ModuleName}}/internal/core/usecase"
)

// RegisterAllRoutes registers all HTTP routes
func RegisterAllRoutes(api huma.API, usecases *usecase.Usecases) {
	// Routes will be registered here automatically
}

var Module = fx.Module(
	"route",
	fx.Invoke(
		RegisterAllRoutes,
	),
)
`

	return os.WriteFile(filepath.Join(routeDir, "routes.go"), []byte(basicRoutes), 0644)
}

func (h *HttpSyncProvider) ensureServerExists() error {
	serverDir := "internal/delivery/http/server"
	serverFile := filepath.Join(serverDir, "server.go")

	// Check if server.go already exists
	if _, err := os.Stat(serverFile); err == nil {
		return nil // Server already exists
	}

	if err := os.MkdirAll(serverDir, 0755); err != nil {
		return err
	}

	serverTemplate := `package server

import (
	"context"
	"fmt"
	"net/http"

	"github.com/danielgtaylor/huma/v2"
	"github.com/danielgtaylor/huma/v2/adapters/humachi"
	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"go.uber.org/fx"

	"{{.ModuleName}}/internal/core/usecase"
	"{{.ModuleName}}/internal/delivery/http/route"
	"{{.ModuleName}}/internal/pkg/logger"
)

// ServerConfig holds server configuration
type ServerConfig struct {
	Port     int    ` + "`" + `yaml:"port" env:"PORT" default:"8080"` + "`" + `
	Host     string ` + "`" + `yaml:"host" env:"HOST" default:"0.0.0.0"` + "`" + `
	BasePath string ` + "`" + `yaml:"base_path" env:"BASE_PATH" default:"/api/v1"` + "`" + `
}

// Server represents the HTTP server
type Server struct {
	config   *ServerConfig
	router   *chi.Mux
	api      huma.API
	usecases *usecase.Usecases
}

// NewServer creates a new HTTP server
func NewServer(config *ServerConfig, usecases *usecase.Usecases) *Server {
	// Create Chi router
	router := chi.NewRouter()

	// Add middleware
	router.Use(middleware.RequestID)
	router.Use(middleware.RealIP)
	router.Use(middleware.Logger)
	router.Use(middleware.Recoverer)
	router.Use(middleware.Compress(5))

	// Create Huma API
	api := humachi.New(router, huma.DefaultConfig("{{.Title}} API", "1.0.0"))

	return &Server{
		config:   config,
		router:   router,
		api:      api,
		usecases: usecases,
	}
}

// Start starts the HTTP server
func (s *Server) Start(ctx context.Context) error {
	log := logger.Get()

	// Register routes
	route.RegisterAllRoutes(s.api, s.usecases)

	addr := fmt.Sprintf("%s:%d", s.config.Host, s.config.Port)

	log.Info().
		Str("addr", addr).
		Str("base_path", s.config.BasePath).
		Msg("Starting HTTP server")

	server := &http.Server{
		Addr:    addr,
		Handler: s.router,
	}

	// Start server in goroutine
	go func() {
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Error().Err(err).Msg("HTTP server error")
		}
	}()

	// Wait for context cancellation
	<-ctx.Done()

	log.Info().Msg("Shutting down HTTP server")
	return server.Shutdown(context.Background())
}

// GetAPI returns the Huma API instance
func (s *Server) GetAPI() huma.API {
	return s.api
}

// GetRouter returns the Chi router
func (s *Server) GetRouter() *chi.Mux {
	return s.router
}

var Module = fx.Module(
	"http_server",
	fx.Provide(
		func() *ServerConfig {
			return &ServerConfig{
				Port:     8080,
				Host:     "0.0.0.0",
				BasePath: "/api/v1",
			}
		},
		NewServer,
	),
)
`

	tmplContent := strings.ReplaceAll(serverTemplate, "{{.ModuleName}}", utils.GetModuleName())
	tmplContent = strings.ReplaceAll(tmplContent, "{{.Title}}", utils.ToTitle(filepath.Base(utils.GetModuleName())))

	return os.WriteFile(serverFile, []byte(tmplContent), 0644)
}

func sortedKeys(m map[string]string) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// RegisterSyncProvider registers this sync provider with the main sync system
func RegisterSyncProvider() {
	// This will be called by vandor sync all to register this provider
	// Implementation depends on how we integrate with the main sync system
}
`

	return os.WriteFile(serverFile, []byte(tmplContent), 0644)
}

func sortedKeys(m map[string]string) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// VpkgSyncIntegration provides the main integration point for vandor sync all
func VpkgSyncIntegration() error {
	provider := NewHttpSyncProvider()
	return provider.SyncRoutes()
}