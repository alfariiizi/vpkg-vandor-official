package dbpagination

import (
	"context"
	"fmt"
	"math"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// PaginationRequest represents the input parameters for pagination
type PaginationRequest struct {
	Page  int `json:"page" query:"page" validate:"min=1"`     // Page number (1-based)
	Limit int `json:"limit" query:"limit" validate:"min=1,max=100"` // Items per page
}

// PaginationService provides pagination functionality with configurable defaults
type PaginationService struct {
	DefaultLimit int // Default items per page
	MaxLimit     int // Maximum items per page allowed
}

// Default is the global singleton pagination service
// Modify these values to change app-wide pagination defaults
var Default = &PaginationService{
	DefaultLimit: 20,  // Change this to modify default page size
	MaxLimit:     100, // Change this to modify maximum page size
}

// PaginationResponse represents the paginated response
type PaginationResponse[T any] struct {
	Data       []T              `json:"data"`
	Pagination PaginationMeta   `json:"pagination"`
}

// PaginationMeta contains pagination metadata
type PaginationMeta struct {
	Page        int  `json:"page"`          // Current page
	Limit       int  `json:"limit"`         // Items per page
	Total       int  `json:"total"`         // Total number of items
	TotalPages  int  `json:"total_pages"`   // Total number of pages
	HasNext     bool `json:"has_next"`      // Whether there is a next page
	HasPrevious bool `json:"has_previous"`  // Whether there is a previous page
}

// DefaultRequest returns default pagination parameters using service config
func (p *PaginationService) DefaultRequest() PaginationRequest {
	return PaginationRequest{
		Page:  1,
		Limit: p.DefaultLimit,
	}
}

// ValidateRequest validates and normalizes pagination parameters using service config
func (p *PaginationService) ValidateRequest(req PaginationRequest) PaginationRequest {
	if req.Page < 1 {
		req.Page = 1
	}
	if req.Limit < 1 {
		req.Limit = p.DefaultLimit
	}
	if req.Limit > p.MaxLimit {
		req.Limit = p.MaxLimit
	}
	return req
}

// Convenience functions that use the default singleton
func DefaultRequest() PaginationRequest {
	return Default.DefaultRequest()
}

func ValidateRequest(req PaginationRequest) PaginationRequest {
	return Default.ValidateRequest(req)
}

// Paginate applies pagination to an Ent query and returns paginated results
func (p *PaginationService) Paginate[T any, Q interface {
	Count(context.Context) (int, error)
	Limit(int) Q
	Offset(int) Q
	All(context.Context) ([]T, error)
}](ctx context.Context, query Q, req PaginationRequest) (*PaginationResponse[T], error) {
	// Validate pagination request using service config
	req = p.ValidateRequest(req)

	// Get total count
	total, err := query.Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count records: %w", err)
	}

	// Calculate pagination metadata
	totalPages := int(math.Ceil(float64(total) / float64(req.Limit)))
	offset := (req.Page - 1) * req.Limit

	// Get paginated data
	data, err := query.
		Limit(req.Limit).
		Offset(offset).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch records: %w", err)
	}

	// Build response
	response := &PaginationResponse[T]{
		Data: data,
		Pagination: PaginationMeta{
			Page:        req.Page,
			Limit:       req.Limit,
			Total:       total,
			TotalPages:  totalPages,
			HasNext:     req.Page < totalPages,
			HasPrevious: req.Page > 1,
		},
	}

	return response, nil
}

// Paginate is a convenience function that uses the default singleton
func Paginate[T any, Q interface {
	Count(context.Context) (int, error)
	Limit(int) Q
	Offset(int) Q
	All(context.Context) ([]T, error)
}](ctx context.Context, query Q, req PaginationRequest) (*PaginationResponse[T], error) {
	return Default.Paginate[T, Q](ctx, query, req)
}

// PaginateWithCustomQuery applies pagination to a custom Ent query with manual count
func (p *PaginationService) PaginateWithCustomQuery[T any](
	ctx context.Context,
	countQuery func(context.Context) (int, error),
	dataQuery func(context.Context, int, int) ([]T, error),
	req PaginationRequest,
) (*PaginationResponse[T], error) {
	// Validate pagination request using service config
	req = p.ValidateRequest(req)

	// Get total count
	total, err := countQuery(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count records: %w", err)
	}

	// Calculate pagination metadata
	totalPages := int(math.Ceil(float64(total) / float64(req.Limit)))
	offset := (req.Page - 1) * req.Limit

	// Get paginated data
	data, err := dataQuery(ctx, req.Limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch records: %w", err)
	}

	// Build response
	response := &PaginationResponse[T]{
		Data: data,
		Pagination: PaginationMeta{
			Page:        req.Page,
			Limit:       req.Limit,
			Total:       total,
			TotalPages:  totalPages,
			HasNext:     req.Page < totalPages,
			HasPrevious: req.Page > 1,
		},
	}

	return response, nil
}

// PaginateWithCustomQuery is a convenience function that uses the default singleton
func PaginateWithCustomQuery[T any](
	ctx context.Context,
	countQuery func(context.Context) (int, error),
	dataQuery func(context.Context, int, int) ([]T, error),
	req PaginationRequest,
) (*PaginationResponse[T], error) {
	return Default.PaginateWithCustomQuery[T](ctx, countQuery, dataQuery, req)
}

// PaginateCursor provides cursor-based pagination for better performance with large datasets
type CursorPaginationRequest struct {
	Limit  int    `json:"limit" query:"limit" validate:"min=1,max=100"`
	Cursor string `json:"cursor,omitempty" query:"cursor"` // Base64 encoded cursor
}

type CursorPaginationResponse[T any] struct {
	Data       []T                   `json:"data"`
	Pagination CursorPaginationMeta  `json:"pagination"`
}

type CursorPaginationMeta struct {
	Limit      int     `json:"limit"`
	HasNext    bool    `json:"has_next"`
	NextCursor *string `json:"next_cursor,omitempty"`
}

// PaginateCursor applies cursor-based pagination to an Ent query
func (p *PaginationService) PaginateCursor[T any, Q interface {
	Limit(int) Q
	Where(...func(*sql.Selector)) Q
	All(context.Context) ([]T, error)
}](
	ctx context.Context,
	query Q,
	req CursorPaginationRequest,
	cursorField string, // The field to use for cursor (e.g., "id", "created_at")
	getCursorValue func(T) interface{}, // Function to extract cursor value from entity
) (*CursorPaginationResponse[T], error) {
	// Validate request using service config
	if req.Limit < 1 {
		req.Limit = p.DefaultLimit
	}
	if req.Limit > p.MaxLimit {
		req.Limit = p.MaxLimit
	}

	// Apply cursor condition if provided
	if req.Cursor != "" {
		// Decode cursor (you might want to implement proper cursor encoding/decoding)
		query = query.Where(sql.GT(cursorField, req.Cursor))
	}

	// Fetch one extra item to check if there's a next page
	data, err := query.Limit(req.Limit + 1).All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch records: %w", err)
	}

	// Check if there's a next page
	hasNext := len(data) > req.Limit
	if hasNext {
		data = data[:req.Limit] // Remove the extra item
	}

	// Generate next cursor
	var nextCursor *string
	if hasNext && len(data) > 0 {
		lastItem := data[len(data)-1]
		cursorValue := getCursorValue(lastItem)
		cursorStr := fmt.Sprintf("%v", cursorValue)
		nextCursor = &cursorStr
	}

	response := &CursorPaginationResponse[T]{
		Data: data,
		Pagination: CursorPaginationMeta{
			Limit:      req.Limit,
			HasNext:    hasNext,
			NextCursor: nextCursor,
		},
	}

	return response, nil
}

// PaginateCursor is a convenience function that uses the default singleton
func PaginateCursor[T any, Q interface {
	Limit(int) Q
	Where(...func(*sql.Selector)) Q
	All(context.Context) ([]T, error)
}](
	ctx context.Context,
	query Q,
	req CursorPaginationRequest,
	cursorField string,
	getCursorValue func(T) interface{},
) (*CursorPaginationResponse[T], error) {
	return Default.PaginateCursor[T, Q](ctx, query, req, cursorField, getCursorValue)
}

// PaginationQueryBuilder helps build paginated queries with filters and sorting
type PaginationQueryBuilder[T any, Q interface {
	Count(context.Context) (int, error)
	Limit(int) Q
	Offset(int) Q
	Order(...func(*sql.Selector)) Q
	Where(...func(*sql.Selector)) Q
	All(context.Context) ([]T, error)
}] struct {
	query   Q
	service *PaginationService
}

// NewPaginationQueryBuilder creates a new pagination query builder using service config
func (p *PaginationService) NewQueryBuilder[T any, Q interface {
	Count(context.Context) (int, error)
	Limit(int) Q
	Offset(int) Q
	Order(...func(*sql.Selector)) Q
	Where(...func(*sql.Selector)) Q
	All(context.Context) ([]T, error)
}](query Q) *PaginationQueryBuilder[T, Q] {
	return &PaginationQueryBuilder[T, Q]{query: query, service: p}
}

// NewPaginationQueryBuilder creates a new pagination query builder using default singleton
func NewPaginationQueryBuilder[T any, Q interface {
	Count(context.Context) (int, error)
	Limit(int) Q
	Offset(int) Q
	Order(...func(*sql.Selector)) Q
	Where(...func(*sql.Selector)) Q
	All(context.Context) ([]T, error)
}](query Q) *PaginationQueryBuilder[T, Q] {
	return Default.NewQueryBuilder[T, Q](query)
}

// WithFilter applies a filter to the query
func (b *PaginationQueryBuilder[T, Q]) WithFilter(filter func(*sql.Selector)) *PaginationQueryBuilder[T, Q] {
	b.query = b.query.Where(filter)
	return b
}

// WithOrder applies ordering to the query
func (b *PaginationQueryBuilder[T, Q]) WithOrder(order func(*sql.Selector)) *PaginationQueryBuilder[T, Q] {
	b.query = b.query.Order(order)
	return b
}

// Paginate executes the paginated query using the builder's service
func (b *PaginationQueryBuilder[T, Q]) Paginate(ctx context.Context, req PaginationRequest) (*PaginationResponse[T], error) {
	return b.service.Paginate[T, Q](ctx, b.query, req)
}
