package vpkgsync

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"{{.Module}}/cmd/utils"
)

type CronSyncProvider struct{}

func NewCronSyncProvider() *CronSyncProvider {
	return &CronSyncProvider{}
}

func (c *CronSyncProvider) SyncJobs() error {
	schedulerDir := "internal/cron/scheduler"
	outputFile := filepath.Join(schedulerDir, "scheduler_registry.go")

	var funcs []string
	funcPattern := regexp.MustCompile(`^Register.*Job$`)

	// Walk through scheduler folder to find job registration functions
	err := filepath.WalkDir(schedulerDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil || d.IsDir() || !strings.HasSuffix(d.Name(), ".go") {
			return nil
		}

		// Skip the registry file itself
		if strings.HasSuffix(path, "scheduler_registry.go") {
			return nil
		}

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.AllErrors)
		if err != nil {
			fmt.Printf("Failed to parse %s: %v\n", path, err)
			return nil
		}

		// Traverse declarations to find Register*Job functions
		for _, decl := range node.Decls {
			if fn, ok := decl.(*ast.FuncDecl); ok {
				if funcPattern.MatchString(fn.Name.Name) {
					funcs = append(funcs, fn.Name.Name)
				}
			}
		}
		return nil
	})

	if err != nil {
		return fmt.Errorf("failed to walk scheduler directory: %v", err)
	}

	// Sort functions for deterministic output
	sort.Strings(funcs)

	// Generate file content
	builder := &strings.Builder{}
	fmt.Fprintln(builder, "// Code generated by Vandor CLI; DO NOT EDIT.")
	fmt.Fprintln(builder, "package scheduler\n")
	importModule := fmt.Sprintf(`import cron "%s/{{.PackagePath}}/init"`, utils.GetModuleName())
	fmt.Fprintln(builder, importModule)
	fmt.Fprintln(builder, "\nfunc RegisterJobs(s *cron.Scheduler) {")

	if len(funcs) == 0 {
		fmt.Fprintln(builder, "\t// No cron jobs found. Add jobs using: vandor vpkg exec vandor/cron add-job <name>")
	} else {
		for _, fn := range funcs {
			fmt.Fprintf(builder, "\t%s(s)\n", fn)
		}
	}

	fmt.Fprintln(builder, "}")

	// Ensure directory exists
	if err := os.MkdirAll(filepath.Dir(outputFile), os.ModePerm); err != nil {
		return fmt.Errorf("failed to create directory: %v", err)
	}

	// Write to file
	if err := os.WriteFile(outputFile, []byte(builder.String()), 0644); err != nil {
		return fmt.Errorf("failed to write file: %v", err)
	}

	fmt.Printf("[CRON] Generated %s with %d jobs.\n", outputFile, len(funcs))
	return nil
}

// VpkgSyncIntegration is the entry point called by vandor sync all
func VpkgSyncIntegration() error {
	provider := NewCronSyncProvider()
	return provider.SyncJobs()
}